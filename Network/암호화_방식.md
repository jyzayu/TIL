## 암호 방식의 분류

### 원문의 변환 방식에 따른 분류
① 치환형 암호 방식

② 전치형 암호 방식

### 키의 운용 방식에 따른 분류
① 대칭키 암호 방식(비밀 키 암호 방식)

② 비대칭키 암호 방식(공개 키 암호 방식)

### 치환형 암호 방식
원문의 구성 단위를 이루는 원래의 값을 다른 값으로 치환하는 암호 방식
[사례]
• Caesar 암호 : 단일문자(Single Alphabet) 치환형 암호 방식의 대표적인 예
• Polybius 암호 : 알파벳을 숫자로 바꾸는 치환형 암호 방식의 예

 ### 전치형 암호 방식
원문의 구성 단위 간에 순서(위치)를 바꾸는 방식

[예]

원문 “동해물과백두산이마르고닳도록하느님이보우하사우리나”를 ‘키=42513’을 사용하여 암호문을 작성
![image](https://github.com/jyzayu/TIL/assets/55649979/6a15fa55-24c1-4a57-90ec-a4fdaea1ab51)


### 대칭키 암호 방식
암호화 키(Encryption key)와 복호화 키(Decryption key)가 동일

= 비밀키 암호방식(Secret Key Cryptography)

[예]
1977년 미국에서 연방정보처리 표준(FIPS 46)으로 채택된 DES(Data Encryption Standard)

### 비대칭키 암호 방식
암호화 키(Encryption key)와 복호화 키(Decryption key)가 다름
= 공개키 암호방식(Public Key Cryptography)

[예]
1978년 MIT의 Ronald Rivest, Adi Shamir와 Leonard Adleman가 개발한 RSA
: 마이크로소프트 웹 브라우저 기능의 일부로 사용

### 비밀키 암호 방식
암호화 키(Encryption key)와 복호화 키(Decryption key)가 동일

(제 3자가 알지 못한 동일한 값을 가지는 암호화 키와 복호화 키를 사용)

![image](https://github.com/jyzayu/TIL/assets/55649979/4859df27-5e56-49af-a18d-e058afa56ae9)

▶ 비밀키 암호방식에서 사용하는 암호화 함수는 이미 공개된 알고리즘을 사용하는 경우가 대부분

▶ 알고리즘이 공개되어도 암호문으로부터 원문을 추출해 낼 수 없도록 하고, 암호화 알고리즘과
암호문으로부터 비밀키를 유추할 수 없도록 해야 함

### 비밀키 암호 방식의 문제점
1) 다수의 비밀키가 요구됨

• 정보 보안을 위해 정보를 교환하는 송신자와 수신자 이외의 제 3자에게 비밀키가 노출되면 안됨

• 모든 사용자들은 다른 상대방과 사용할 별도의 비밀키를 가져야 함

• 만일 사용자 A, B, C가 서로 동일한 서비스를 사용하고 있다면 ‘A↔B’,’A↔C’,’B↔C’간에 사용 할
별도의 비밀키가 있어야 함

2) 비밀키 교환이 어려움

• 멀리 떨어져 있는 A가 비밀키를 만들어 B에게 전달하는 경우

- 통신망 이용 → 보안상의 문제 발생

- 직접 만나서 전달 → 현실적으로 불가능

### 인증의 개념
1) 사용자 인증

• 통신망이 개발되어 통신망을 통한 정보의 전달과 이용이 언제, 어디서든 자유롭게 됨

• 불법적인 사용자에 의한 주요 정보의 절취, 변경, 삭제 등이 발생하는 역기능도 내포

• 정당한 사용자에 의한 접속을 확인하기 위한 사용자 인증이 통신망 운영에 필수 요건

![image](https://github.com/jyzayu/TIL/assets/55649979/c2e6beb6-d561-4d43-8f6f-8da4f3e4cd6c)

2) 메시지 인증

• 전송 중 발생할 수 있는 내용 변경, 순서 변경, 삭제 여부를 확인하는 기능

• 수신자가 받은 메시지와 송신자가 보낸 메시지가 동일한 메시지임을 확인하는 기능

• 전송 중 메시지의 변경 여부 확인 가능


3) 메시지 인증 방법의 종류

• 비밀키를 이용하는 방식

• 해쉬 함수를 이용하는 방식

[비밀키를 이용하는 방식]

![image](https://github.com/jyzayu/TIL/assets/55649979/45417a05-8ab2-4157-8ea4-2685d9f83c82)

• 사용자 A가 메시지 M을 암호화한 암호문 C를 전송하면 인증자 B만이 암호문 C에서
메시지 M을 복원할 수 있음

• 사용자 A와 인증자 B는 사전에 동일한 키를 갖고 있어야 함

[해쉬 함수를 이용하는 방식]

해쉬 함수(Hash Function)

임의의 길이를 갖는 입력 값에 대해 고정 길이의 해쉬 값(H)을 출력하는 함수

![image](https://github.com/jyzayu/TIL/assets/55649979/b2130500-0e2e-43d6-9f90-f943caf3e44c)

* 메시지 다이제스트 H= h(M)를 원래의 메시지 M과 함께 전송하면 이를 수신한 수신자는 메시지 M에 대한

메시지 다이제스트를 계산하고, 수신한 메시지 다이제스트와 비교하여 그 값이 같으면 메시지를 인증함

### 공개키 암호 방식의 개요
비대칭형 암호 방식 : 암호화 키와 복호화 키가 동일하지 않은 암호 방식

두 개의 키 사용 – 공개키, 개인키 : 반드시 쌍(pair)으로 존재

![image](https://github.com/jyzayu/TIL/assets/55649979/f52dde97-770e-4ed1-b233-f9233a14e52f)

비밀리에 키를 전송할 필요가 없기 때문에 비밀키 암호 방식의 가장 큰 단점인 키 전송의 문제가 발생하지 않는다는 장점을 가짐

### 공개키 암호 방식의 운용
[공개키 암호 방식을 이용한 비밀키 전달]

• 비밀키 암호 방식은 공개키 암호방식에 비해 암호화와 복호화를 훨씬 빠르게 처리하기 때문에

이를 이용해 비밀키를 전달하는 경우가 많음

• 원문 전체를 암호화하는 경우 처리 시간이 오래 걸림

→ 1회용 비밀키(one-time secret key)를 생성하여 암호화와 복호화에 사용

![image](https://github.com/jyzayu/TIL/assets/55649979/7d8d4ae6-8813-47c7-87e1-a44925ec1573)

① A는 1회용 비밀키를 생성, 이를 이용하여 원문을 암호화

② 1회용 비밀키를 B의 공개키로 암호화

③ 1회용 비밀키로 암호화한 암호문과 B의 공개키로 암호화한
1회용 비밀키를 B에게 전달함.

④ B는 암호화된 1회용 비밀키를 자신의 개인키로 복호화하여

A의 비밀키를 얻고, 이용하여 A가 보내온 암호문을 복호화하여
원문을 얻음.


[전자 서명을 이용한 메시지 인증]
• 전자서명(digital signature) : 원문에 대한 해쉬 함수의 결과인 메시지 다이제스트를 송신자의 개인키로 암호화한 것

• 원문이 전송 중에 훼손 또는 변경을 확인(메시지 인증)하거나 원문을 보낸 송신자를 인증(사용자 인증)할 때 활용

![image](https://github.com/jyzayu/TIL/assets/55649979/f744d221-4b9e-44cb-a3d8-4be51bfae2ea)
① A는 원문을 B의 공개키를 사용하여 암호화한 암호문과, 원문에 대한 메시지 다이제스트를 A의 개인키로 암호화한 전자서명을 B로 전송

② B는 A가 보내온 암호문을 자신의 개인키로 복호화하여 원문을 얻고, A의 전자서명을 A의 공개키로 복호화하여 원문에 대한 메시지 다이제스트를 구함

③ B는 복호화한 원문에 대한 메시지 다이제스트를 구한 후 A가 보낸 메시지 다이제스트와 일치하는가를 확인

④ A가 보낸 메시지 다이제스트와 B가 계산한 메시지 다이제스트가 일치하는 경우, 원문이 변경 없이 수신되었다는 것을 확인

## 공개키 기반 구조(PKI : Public Key Infrastructure)의 개요

공개키 암호방식을 효율적으로 사용하기 위해 요구되는 제반 객체들과
운용 방법을 포함하는 집합체

### [PKI의 다양한 정의]
• 사용자의 공개키를 인증해 주는 인증기관들의 네트워크

• 모르는 사람과의 비밀 통신을 가능하게 하는 암호학적 키
와 인증서의 배달 시스템

• 공개키의 인증서를 이용해 공개키를 자동적으로 관리하는
기반 구조

• 공개키의 인증서를 발행하고 그에 대한 접근을 제공하는
인증서 관리 기반 구조
### [PKI의 기능 및 역할]
• 개방형 네트워크, 분산형 네트워크 환경에서 보안 요구
사항을 만족시키기 위해 공개키 암호와 인증서의 사용을
가능하게 하는 새로운 기반 구조 요구

→ 정보 보안이 요구되는 모든 통신망에서 매우 중요

### PKI가 제공하는 서비스
통신망을 이용해 전송되는 메시지는 도청, 변조, 위조, 송·수신 부인 등의
위험요소가 항상 존재

• 기밀성(confidentiality) : 정보 암호화를 통한 정보보호

• 무결성(integrity) : 정보의 위조, 변조 방지

• 인증(authentication) : 정보 송신자 혹은 수신자에 대한 신원확인

• 부인방지(non-repudiation) : 전자서명을 송수신 정보의 부인방지

• 접근제어(access control) : 허용된 사용자만이 정보에 접근 허용

### < PKI의 구성 요소
① 사용자(User)

PKI를 이용하는 사람 및 시스템

② 등록 기관(RA : Registration Authority)
- 사용자와 인증 기관 사이에 위치
- 사용자의 인증서 신청 시 인증 기관을 대신하여 확인
- 사용자의 인증 요청 승인, 정당성 확인, 인증 기관에 요청서 전송
③ 인증 기관(CA : Certification Authority)
- 인증서 등록, 발급, 취소, 공표, 보관 등을 담당
- 전자적인 공증, 키 복구 등의 부가 서비스 제공
④ 디렉토리(Directory)
- 인증서와 사용자 관련 정보, 상호 인증서 쌍 및
인증서 취소 목록 등을 저장 및 검색하는 장소
- 서버를 설치하거나 인증 기관에서 관리
- 인증 기관은 인증서 발급과 동시에 디렉토리에 저장, 사용자는 원하는 인증서 검색 가능

### PKI 동작
![image](https://github.com/jyzayu/TIL/assets/55649979/7f51b899-21ad-4726-94c2-5e6fede479f7)


